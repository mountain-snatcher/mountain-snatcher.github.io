<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasma Field Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
            box-sizing: border-box;
        }
        #info.collapsed {
            transform: translateX(-280px);
        }
        #toggle-info {
            position: absolute;
            top: 15px;
            right: -30px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        #toggle-info:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #info h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        #info p, #info ul {
            margin: 5px 0;
            line-height: 1.4;
        }
        #info ul {
            padding-left: 20px;
        }
        #info li {
            margin: 3px 0;
        }
        .dg.main {
            position: absolute !important;
            top: 10px !important;
            right: 10px !important;
            z-index: 100 !important;
        }
        @media (max-width: 768px) {
            #info {
                max-width: 250px;
                font-size: 12px;
                padding: 10px;
                left: 0;
            }
            #info.collapsed {
                transform: translateX(-100%);
            }
            #toggle-info {
                right: -25px;
                padding: 6px 8px;
                font-size: 14px;
            }
            .dg.main {
                transform: scale(0.8);
                transform-origin: top right;
            }
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 18px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>
    <div id="loading">Loading Plasma Field Simulation...</div>
    <div id="info">
        <button id="toggle-info">â—€</button>
        <h3>Plasma Field Visualization</h3>
        <p>Plasma is the fourth state of matter, consisting of ionized gas with free electrons and ions. This simulation visualizes a dynamic plasma field within a containment sphere, showing glowing particles representing charged particles moving under electromagnetic influences.</p>
        <p><strong>Educational Insights:</strong></p>
        <ul>
            <li>Particles exhibit random thermal motion with directional flows simulating magnetic confinement.</li>
            <li>Bloom effects highlight high-energy interactions.</li>
            <li>Adjust parameters to explore plasma behavior.</li>
        </ul>
        <p><strong>Controls:</strong></p>
        <ul>
            <li>Drag to rotate view</li>
            <li>Scroll to zoom</li>
            <li>Mobile: Touch to rotate/pinch to zoom</li>
            <li>Use right panel for adjustments</li>
        </ul>
    </div>
    <div id="error" style="display: none;"></div>
    <script>
        // Single, well-structured ES6 class for the simulation
        class PlasmaFieldSimulation {
            constructor() {
                // Core Three.js objects
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.gui = null;
                this.composer = null;
                this.usePostProcessing = false;

                // Enhanced simulation parameters
                this.params = {
                    animationSpeed: 1.2,      // Speed of particle movement
                    electronCount: 3000,      // Number of electrons (blue, small, fast)
                    ionCount: 2000,           // Number of ions (red, medium, slower)
                    neutralCount: 1000,       // Number of neutrals (white, large, slow)
                    bloomStrength: 2.2,       // Intensity of glow effect
                    bloomRadius: 0.6,         // Spread of bloom
                    bloomThreshold: 0.6,      // Brightness threshold for bloom
                    lightningIntensity: 0.8,  // Lightning frequency
                    mouseForce: 2.0,          // Mouse interaction strength
                    energyLevel: 1.0          // Overall energy level
                };

                // Plasma-specific objects - multiple particle types
                this.electronSystem = null;
                this.ionSystem = null;
                this.neutralSystem = null;
                this.lightningSystem = null;
                this.lightningLines = [];
                this.clock = new THREE.Clock();
                
                // Mouse interaction
                this.mouse = new THREE.Vector2();
                this.mouseWorld = new THREE.Vector3();
                this.mouseInfluence = 0;

                // UI elements
                this.infoPanel = null;
                this.toggleBtn = null;
            }

            // Initialize the simulation after dependency checks
            init() {
                // Step 1: Validate core dependencies
                if (typeof THREE === 'undefined') {
                    this.showError('THREE.js failed to load');
                    return;
                }
                if (typeof THREE.OrbitControls === 'undefined') {
                    this.showError('OrbitControls failed to load');
                    return;
                }
                if (typeof dat === 'undefined') {
                    console.warn('dat.GUI not loaded, controls disabled');
                }

                // Step 2: Check post-processing availability
                this.usePostProcessing = typeof THREE.EffectComposer !== 'undefined' &&
                                         typeof THREE.ShaderPass !== 'undefined' &&
                                         typeof THREE.RenderPass !== 'undefined' &&
                                         typeof THREE.UnrealBloomPass !== 'undefined';
                if (!this.usePostProcessing) {
                    console.warn('Post-processing dependencies missing, falling back to basic rendering');
                }

                // Step 3: Hide loading indicator
                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';

                // Step 4: Setup scene, camera, renderer
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.setupLighting();
                this.createEnvironment();
                this.createMultipleParticleTypes();
                this.createLightningSystem();
                this.setupContainment();
                this.setupMouseInteraction();
                if (this.usePostProcessing) {
                    this.setupPostProcessing();
                }
                this.setupControls();
                if (typeof dat !== 'undefined') {
                    this.setupGUI();
                }
                this.setupUI();

                // Step 5: Start animation loop
                this.animate();
            }

            // Setup the main scene
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000008); // Deep space black
                // Add subtle fog for depth
                this.scene.fog = new THREE.Fog(0x000008, 8, 25);
            }

            // Setup perspective camera
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 5, 10);
            }

            // Setup WebGL renderer with shadow support and high quality
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for realism
                this.renderer.physicallyCorrectLights = true; // Enable PBR lighting model
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.body.appendChild(this.renderer.domElement);

                // Handle window resize for responsiveness
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    if (this.usePostProcessing && this.composer) {
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }
                }, false);
            }

            // Setup physically-accurate lighting: Hemisphere for ambient, Directional for key light and shadows
            setupLighting() {
                // Hemisphere light for soft, natural ambient illumination
                const hemiLight = new THREE.HemisphereLight(0x444444, 0x000011, 0.6);
                hemiLight.position.set(0, 20, 0);
                this.scene.add(hemiLight);

                // Directional light for sharp shadows and highlights (simulating a strong energy source)
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
                dirLight.position.set(10, 10, 5);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.camera.left = -10;
                dirLight.shadow.camera.right = 10;
                dirLight.shadow.camera.top = 10;
                dirLight.shadow.camera.bottom = -10;
                this.scene.add(dirLight);
            }

            // Create environment: Pure space environment
            createEnvironment() {
                // No ground plane - pure floating space effect
                // Set scene background to deep space
                this.scene.background = new THREE.Color(0x000008);
            }

            // Create multiple particle types for realistic plasma composition
            createMultipleParticleTypes() {
                // Electrons: Small, fast, blue particles
                this.electronSystem = this.createParticleType({
                    count: this.params.electronCount,
                    color: 0x0088ff,
                    size: 1.2,
                    mass: 1,
                    charge: -1,
                    speed: 0.15
                });

                // Ions: Medium, slower, red/orange particles  
                this.ionSystem = this.createParticleType({
                    count: this.params.ionCount,
                    color: 0xff4400,
                    size: 1.8,
                    mass: 10,
                    charge: 1,
                    speed: 0.08
                });

                // Neutral atoms: Large, slow, white/purple particles
                this.neutralSystem = this.createParticleType({
                    count: this.params.neutralCount,
                    color: 0xaa88ff,
                    size: 2.2,
                    mass: 15,
                    charge: 0,
                    speed: 0.04
                });
            }

            // Create individual particle type system
            createParticleType(config) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.count * 3);
                const velocities = new Float32Array(config.count * 3);

                // Initialize particles with clustered distribution
                for (let i = 0; i < config.count; i++) {
                    const i3 = i * 3;
                    // Create clusters and filaments
                    const clusterIndex = Math.floor(Math.random() * 4);
                    const clusterAngle = (clusterIndex / 4) * Math.PI * 2;
                    const clusterRadius = 1.2 + Math.random() * 1.8;
                    
                    const localRadius = Math.pow(Math.random(), 0.6) * 0.9;
                    const theta = clusterAngle + (Math.random() - 0.5) * Math.PI * 0.4;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = clusterRadius * Math.cos(clusterAngle) + localRadius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = clusterRadius * Math.sin(clusterAngle) + localRadius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = localRadius * Math.cos(phi);

                    // Type-specific velocities
                    const swirl = 0.04 / config.mass;
                    velocities[i3] = (Math.random() - 0.5) * config.speed + swirl * -positions[i3 + 1];
                    velocities[i3 + 1] = (Math.random() - 0.5) * config.speed + swirl * positions[i3];
                    velocities[i3 + 2] = (Math.random() - 0.5) * config.speed * 0.6;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Type-specific material
                const material = new THREE.PointsMaterial({
                    color: config.color,
                    size: config.size,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.85,
                    blending: THREE.AdditiveBlending,
                    map: this.createParticleTexture(),
                    alphaTest: 0.001,
                    depthWrite: false
                });

                const system = new THREE.Points(geometry, material);
                system.userData = {
                    config: config,
                    positions: positions,
                    velocities: velocities
                };
                
                this.scene.add(system);
                return system;
            }

            // High-quality procedural texture for smooth circular particles
            createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;  // Higher resolution
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const center = 64;
                
                // Create smooth radial gradient with multiple stops
                const gradient = ctx.createRadialGradient(center, center, 0, center, center, center);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.1, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.3, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.3)');
                gradient.addColorStop(0.8, 'rgba(255,255,255,0.1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.generateMipmaps = false;
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                return texture;
            }

            // Create lightning system for electrical arcing effects
            createLightningSystem() {
                this.lightningLines = [];
                
                // Pre-create lightning line objects for performance
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6); // 2 points, 3 coords each
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    const material = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0,
                        linewidth: 2,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    this.scene.add(line);
                    
                    this.lightningLines.push({
                        line: line,
                        active: false,
                        lifetime: 0,
                        maxLifetime: 0.3,
                        intensity: 0
                    });
                }
            }

            // No visible containment - particles contained by physics boundaries
            setupContainment() {
                // Containment sphere removed for cleaner visualization
            }

            // Setup mouse interaction for disturbing the plasma field
            setupMouseInteraction() {
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousemove', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Convert mouse to world coordinates
                    const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
                    vector.unproject(this.camera);
                    const dir = vector.sub(this.camera.position).normalize();
                    const distance = -this.camera.position.z / dir.z;
                    this.mouseWorld.copy(this.camera.position).add(dir.multiplyScalar(distance));
                });

                canvas.addEventListener('mouseenter', () => {
                    this.mouseInfluence = 1.0;
                });

                canvas.addEventListener('mouseleave', () => {
                    this.mouseInfluence = 0.0;
                });
            }

            // Setup OrbitControls for interaction (mouse/touch)
            setupControls() {
                if (THREE.OrbitControls) {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true; // Smooth movement
                    this.controls.dampingFactor = 0.05;
                    this.controls.minDistance = 2;
                    this.controls.maxDistance = 50;
                    this.controls.maxPolarAngle = Math.PI; // Allow full rotation since no ground
                }
            }

            // Setup post-processing pipeline for cinematic bloom effect on plasma
            setupPostProcessing() {
                this.composer = new THREE.EffectComposer(this.renderer);
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                // UnrealBloomPass for glowing plasma highlights
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    this.params.bloomStrength, // Strength
                    this.params.bloomRadius,   // Radius
                    this.params.bloomThreshold // Threshold
                );
                this.composer.addPass(bloomPass);
            }

            // Setup dat.GUI controls (only for defined params)
            setupGUI() {
                this.gui = new dat.GUI();
                this.gui.domElement.style.position = 'absolute';
                this.gui.domElement.style.top = '10px';
                this.gui.domElement.style.right = '10px';
                this.gui.domElement.style.zIndex = '100';

                // Enhanced controls for multiple particle systems
                this.gui.add(this.params, 'animationSpeed', 0, 3).name('Animation Speed');
                this.gui.add(this.params, 'electronCount', 500, 5000, 100).name('Electrons').onChange(() => this.updateParticleCounts());
                this.gui.add(this.params, 'ionCount', 500, 4000, 100).name('Ions').onChange(() => this.updateParticleCounts());
                this.gui.add(this.params, 'neutralCount', 200, 2000, 50).name('Neutrals').onChange(() => this.updateParticleCounts());
                this.gui.add(this.params, 'energyLevel', 0.1, 3).name('Energy Level');
                this.gui.add(this.params, 'lightningIntensity', 0, 2).name('Lightning');
                this.gui.add(this.params, 'mouseForce', 0, 5).name('Mouse Force');
                if (this.usePostProcessing) {
                    const bloomFolder = this.gui.addFolder('Bloom Effect');
                    bloomFolder.add(this.params, 'bloomStrength', 0, 3).name('Strength').onChange(() => this.updateBloom());
                    bloomFolder.add(this.params, 'bloomRadius', 0, 1).name('Radius').onChange(() => this.updateBloom());
                    bloomFolder.add(this.params, 'bloomThreshold', 0, 1).name('Threshold').onChange(() => this.updateBloom());
                    bloomFolder.open();
                }
                this.gui.open();
            }

            // Update particle counts dynamically (regenerate systems)
            updateParticleCounts() {
                // Remove existing systems
                if (this.electronSystem) {
                    this.scene.remove(this.electronSystem);
                    this.electronSystem = null;
                }
                if (this.ionSystem) {
                    this.scene.remove(this.ionSystem);
                    this.ionSystem = null;
                }
                if (this.neutralSystem) {
                    this.scene.remove(this.neutralSystem);
                    this.neutralSystem = null;
                }
                
                // Recreate with new counts
                this.createMultipleParticleTypes();
            }

            // Update bloom parameters
            updateBloom() {
                if (this.usePostProcessing && this.composer) {
                    // UnrealBloomPass requires recreation for param updates in r140
                    this.composer.passes = []; // Clear
                    const renderPass = new THREE.RenderPass(this.scene, this.camera);
                    this.composer.addPass(renderPass);
                    const bloomPass = new THREE.UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        this.params.bloomStrength,
                        this.params.bloomRadius,
                        this.params.bloomThreshold
                    );
                    this.composer.addPass(bloomPass);
                }
            }

            // Setup toggleable UI elements
            setupUI() {
                this.infoPanel = document.getElementById('info');
                this.toggleBtn = document.getElementById('toggle-info');
                if (this.toggleBtn && this.infoPanel) {
                    this.toggleBtn.addEventListener('click', () => {
                        this.infoPanel.classList.toggle('collapsed');
                        this.toggleBtn.innerHTML = this.infoPanel.classList.contains('collapsed') ? 'â–¶' : 'â—€';
                    });
                }
            }

            // Show error message and halt
            showError(message) {
                const errorDiv = document.getElementById('error');
                errorDiv.innerHTML = `<h2>Error</h2><p>${message}</p><p>Please refresh the page or check your connection.</p>`;
                errorDiv.style.display = 'block';
                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';
                console.error(message);
            }

            // Animation loop: Update particles, controls, and render
            animate() {
                requestAnimationFrame(() => this.animate());

                const delta = this.clock.getDelta() * this.params.animationSpeed;

                // Update controls if available
                if (this.controls) {
                    this.controls.update();
                }

                // Update all particle systems with enhanced physics
                this.updateParticleSystem(this.electronSystem, delta);
                this.updateParticleSystem(this.ionSystem, delta);
                this.updateParticleSystem(this.neutralSystem, delta);

                // Update lightning effects
                this.updateLightning(delta);


                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }

            // Enhanced particle system update with type-specific physics
            updateParticleSystem(system, delta) {
                if (!system || !system.userData) return;

                const { config, positions, velocities } = system.userData;
                const positionsArray = system.geometry.attributes.position.array;
                const radius = 3.2;
                const time = this.clock.getElapsedTime();

                for (let i = 0; i < config.count; i++) {
                    const i3 = i * 3;
                    
                    // Current position
                    const x = positionsArray[i3];
                    const y = positionsArray[i3 + 1];
                    const z = positionsArray[i3 + 2];
                    const dist = Math.sqrt(x*x + y*y + z*z);

                    // Mouse interaction force
                    if (this.mouseInfluence > 0) {
                        const mouseDistX = x - this.mouseWorld.x;
                        const mouseDistY = y - this.mouseWorld.y;
                        const mouseDistZ = z - this.mouseWorld.z;
                        const mouseDist = Math.sqrt(mouseDistX*mouseDistX + mouseDistY*mouseDistY + mouseDistZ*mouseDistZ);
                        
                        if (mouseDist < 2.0 && mouseDist > 0.1) {
                            const mouseForce = this.params.mouseForce * this.mouseInfluence / (mouseDist * mouseDist);
                            const forceDirection = config.charge; // Electrons attracted, ions repelled
                            velocities[i3] += (mouseDistX / mouseDist) * mouseForce * forceDirection * delta;
                            velocities[i3 + 1] += (mouseDistY / mouseDist) * mouseForce * forceDirection * delta;
                            velocities[i3 + 2] += (mouseDistZ / mouseDist) * mouseForce * forceDirection * delta * 0.5;
                        }
                    }

                    // Type-specific electromagnetic forces
                    if (config.charge !== 0) {
                        const fieldStrength = 0.008 * (1 + 0.3 * Math.sin(time * 2)) / config.mass;
                        const dx = -x * fieldStrength;
                        const dy = -y * fieldStrength;
                        const dz = -z * fieldStrength * 0.5;
                        
                        // Cyclotron motion (charge-dependent)
                        const cyclotronFreq = 0.6 * config.charge / config.mass;
                        const cyclotronX = y * cyclotronFreq * delta;
                        const cyclotronY = -x * cyclotronFreq * delta;
                        
                        velocities[i3] += dx + cyclotronX;
                        velocities[i3 + 1] += dy + cyclotronY;
                        velocities[i3 + 2] += dz;
                    }

                    // Thermal motion (mass-dependent)
                    const thermalForce = 0.02 * this.params.energyLevel / Math.sqrt(config.mass);
                    velocities[i3] += (Math.random() - 0.5) * thermalForce * delta;
                    velocities[i3 + 1] += (Math.random() - 0.5) * thermalForce * delta;
                    velocities[i3 + 2] += (Math.random() - 0.5) * thermalForce * delta * 0.5;

                    // Update positions
                    positionsArray[i3] += velocities[i3] * delta;
                    positionsArray[i3 + 1] += velocities[i3 + 1] * delta;
                    positionsArray[i3 + 2] += velocities[i3 + 2] * delta;

                    // Containment boundary
                    const newDist = Math.sqrt(positionsArray[i3]**2 + positionsArray[i3 + 1]**2 + positionsArray[i3 + 2]**2);
                    if (newDist > radius) {
                        const normalX = positionsArray[i3] / newDist;
                        const normalY = positionsArray[i3 + 1] / newDist;
                        const normalZ = positionsArray[i3 + 2] / newDist;
                        
                        positionsArray[i3] = normalX * radius;
                        positionsArray[i3 + 1] = normalY * radius;
                        positionsArray[i3 + 2] = normalZ * radius;
                        
                        // Elastic collision with energy loss
                        const dot = velocities[i3] * normalX + velocities[i3 + 1] * normalY + velocities[i3 + 2] * normalZ;
                        const damping = 0.7;
                        velocities[i3] -= 2 * dot * normalX * damping;
                        velocities[i3 + 1] -= 2 * dot * normalY * damping;
                        velocities[i3 + 2] -= 2 * dot * normalZ * damping;
                    }

                    // Velocity damping
                    velocities[i3] *= 0.998;
                    velocities[i3 + 1] *= 0.998;
                    velocities[i3 + 2] *= 0.998;
                }

                system.geometry.attributes.position.needsUpdate = true;
            }

            // Update lightning/arcing effects
            updateLightning(delta) {
                const time = this.clock.getElapsedTime();
                
                // Update existing lightning
                this.lightningLines.forEach(lightning => {
                    if (lightning.active) {
                        lightning.lifetime -= delta;
                        lightning.intensity = lightning.lifetime / lightning.maxLifetime;
                        lightning.line.material.opacity = lightning.intensity * 0.8;
                        
                        if (lightning.lifetime <= 0) {
                            lightning.active = false;
                            lightning.line.material.opacity = 0;
                        }
                    }
                });

                // Create new lightning bolts randomly
                if (Math.random() < this.params.lightningIntensity * delta * 2) {
                    this.createLightningBolt();
                }
            }

            // Create individual lightning bolt between particle clusters
            createLightningBolt() {
                // Find inactive lightning line
                const lightning = this.lightningLines.find(l => !l.active);
                if (!lightning) return;

                // Get random particles from different systems for connection
                const systems = [this.electronSystem, this.ionSystem, this.neutralSystem].filter(s => s);
                if (systems.length < 2) return;

                const system1 = systems[Math.floor(Math.random() * systems.length)];
                const system2 = systems[Math.floor(Math.random() * systems.length)];

                const pos1 = system1.geometry.attributes.position.array;
                const pos2 = system2.geometry.attributes.position.array;

                const idx1 = Math.floor(Math.random() * system1.userData.config.count) * 3;
                const idx2 = Math.floor(Math.random() * system2.userData.config.count) * 3;

                // Check if particles are close enough for arcing
                const dx = pos1[idx1] - pos2[idx2];
                const dy = pos1[idx1 + 1] - pos2[idx2 + 1];
                const dz = pos1[idx1 + 2] - pos2[idx2 + 2];
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (distance < 1.5 && distance > 0.2) { // Suitable distance for arcing
                    const positions = lightning.line.geometry.attributes.position.array;
                    positions[0] = pos1[idx1];
                    positions[1] = pos1[idx1 + 1];
                    positions[2] = pos1[idx1 + 2];
                    positions[3] = pos2[idx2];
                    positions[4] = pos2[idx2 + 1];
                    positions[5] = pos2[idx2 + 2];

                    lightning.line.geometry.attributes.position.needsUpdate = true;
                    lightning.active = true;
                    lightning.lifetime = lightning.maxLifetime;
                    lightning.intensity = 1.0;
                    
                    // Color based on particle types
                    const color = new THREE.Color().lerpColors(
                        new THREE.Color(system1.material.color),
                        new THREE.Color(system2.material.color),
                        0.5
                    );
                    lightning.line.material.color = color;
                }
            }

        }

        // Initialization after DOM load and script availability
        document.addEventListener('DOMContentLoaded', () => {
            // Final dependency check
            if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined' || typeof dat === 'undefined') {
                const simulation = new PlasmaFieldSimulation();
                simulation.showError('Required libraries failed to load. Please check your internet connection.');
                return;
            }

            // Check post-processing (warn only, proceed without)
            const hasPostProcessing = typeof THREE.EffectComposer !== 'undefined' && typeof THREE.UnrealBloomPass !== 'undefined';
            if (!hasPostProcessing) {
                console.warn('Post-processing not fully available, simulation will run without bloom effects.');
            }

            // Start simulation
            const simulation = new PlasmaFieldSimulation();
            simulation.init();
        });
    </script>
</body>
</html>